audio_source_url: https://www.tumblr.com/audio_file/abandonmentprobability/58490554576/tumblr_mrnxghujPv1qim2zw
audio_type: tumblr
audio_url: https://www.tumblr.com/audio_file/abandonmentprobability/58490554576/tumblr_mrnxghujPv1qim2zw
blog_name: abandonmentprobability
caption: "<p>Did you know you can put (almost) arbitrary data into a WAV file&rsquo;s\
  \ PCM stream? It&rsquo;s true, and the results sound as mechanical and unlistenable\
  \ as you might expect. In the spirit of the old Everything2 node <a href=\"http://everything2.com/title/catting+weird+things+to+%252Fdev%252Faudio\"\
  >&ldquo;catting weird things to /dev/audio&rdquo;</a>, here&rsquo;s how I created\
  \ this:</p>\n\n<pre><code>$ curl -s <a href=\"https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh\"\
  >https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh</a> | \\\
  \n  ffmpeg -codec:a pcm_s16le -f s16le -ac 2 -i - -f wav output.wav\n</code></pre>\n\
  \n<p>A breakdown of the above FFmpeg invocation:</p>\n\n<ul><li><p><code>-codec:a</code>\
  \ specifies the audio codec I want to use to decode the input data. Here, we&rsquo;re\
  \ pretending the C++ header file I fetch using <code>curl</code> is actually signed\
  \ 16-bit little-endian PCM audio data. You may also know this option as <code>-acodec</code>.</p></li>\n\
  <li><p><code>-f s16le</code> specifies the input file format, which in this case\
  \ is basically the same as the audio codec. This is necessary to make FFmpeg understand\
  \ that we&rsquo;re providing it with raw data, and not expect file headers or metadata\
  \ or what have you.</p></li>\n<li><p><code>-ac 2</code> tells FFmpeg to treat the\
  \ input as having two audio channels, in essence stereo audio. You can leave this\
  \ off and get mono audio; with the same data, it sounds like it&rsquo;s being played\
  \ at half-speed.</p></li>\n<li><p><code>-i -</code> means that the data is coming\
  \ from standard input.</p></li>\n<li><p><code>-f wav</code> specifies the output\
  \ file format. You might be thinking, &ldquo;Wait, didn&rsquo;t you already use\
  \ <code>-f</code>?&rdquo; Indeed I did. Options that come before <code>-i</code>\
  \ generally apply to the input stream, while options after it apply to the output\
  \ stream. Intuitive, huh?</p></li>\n</ul><p>As is my usual admonition, don&rsquo;t\
  \ do this.</p>"
date: 2013-08-17 06:45:00 GMT
embed: <iframe class="tumblr_audio_player tumblr_audio_player_58490554576" src="http://blog.room208.org/post/58490554576/audio_player_iframe/abandonmentprobability/tumblr_mrnxghujPv1qim2zw?audio_file=https%3A%2F%2Fwww.tumblr.com%2Faudio_file%2Fabandonmentprobability%2F58490554576%2Ftumblr_mrnxghujPv1qim2zw"
  frameborder="0" allowtransparency="true" scrolling="no" width="540" height="85"></iframe>
format: markdown
highlighted: []
id: 58490554576
note_count: 0
player: <embed type="application/x-shockwave-flash" src="http://assets.tumblr.com/swf/audio_player.swf?audio_file=https%3A%2F%2Fwww.tumblr.com%2Faudio_file%2Fabandonmentprobability%2F58490554576%2Ftumblr_mrnxghujPv1qim2zw&color=FFFFFF"
  height="27" width="207" quality="best" wmode="opaque"></embed>
plays: 11
post_url: http://blog.room208.org/post/58490554576/did-you-know-you-can-put-almost-arbitrary-data
reblog: {comment: "<p>Did you know you can put (almost) arbitrary data into a WAV\
    \ file\u2019s PCM stream? It\u2019s true, and the results sound as mechanical\
    \ and unlistenable as you might expect. In the spirit of the old Everything2 node\
    \ <a href=\"http://everything2.com/title/catting+weird+things+to+%252Fdev%252Faudio\"\
    >\u201Ccatting weird things to /dev/audio\u201D</a>, here\u2019s how I created\
    \ this:</p>\n\n<pre><code>$ curl -s <a href=\"https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh\"\
    >https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh</a> |\
    \ \\\n  ffmpeg -codec:a pcm_s16le -f s16le -ac 2 -i - -f wav output.wav\n</code></pre>\n\
    \n<p>A breakdown of the above FFmpeg invocation:</p>\n\n<ul><li><p><code>-codec:a</code>\
    \ specifies the audio codec I want to use to decode the input data. Here, we\u2019\
    re pretending the C++ header file I fetch using <code>curl</code> is actually\
    \ signed 16-bit little-endian PCM audio data. You may also know this option as\
    \ <code>-acodec</code>.</p></li>\n<li><p><code>-f s16le</code> specifies the input\
    \ file format, which in this case is basically the same as the audio codec. This\
    \ is necessary to make FFmpeg understand that we\u2019re providing it with raw\
    \ data, and not expect file headers or metadata or what have you.</p></li>\n<li><p><code>-ac\
    \ 2</code> tells FFmpeg to treat the input as having two audio channels, in essence\
    \ stereo audio. You can leave this off and get mono audio; with the same data,\
    \ it sounds like it\u2019s being played at half-speed.</p></li>\n<li><p><code>-i\
    \ -</code> means that the data is coming from standard input.</p></li>\n<li><p><code>-f\
    \ wav</code> specifies the output file format. You might be thinking, \u201CWait,\
    \ didn\u2019t you already use <code>-f</code>?\u201D Indeed I did. Options that\
    \ come before <code>-i</code> generally apply to the input stream, while options\
    \ after it apply to the output stream. Intuitive, huh?</p></li>\n</ul><p>As is\
    \ my usual admonition, don\u2019t do this.</p>", tree_html: ''}
reblog_key: droLLocs
recommended_color: null
recommended_source: null
short_url: http://tmblr.co/ZnGqcxsUJmZG
slug: did-you-know-you-can-put-almost-arbitrary-data
state: published
summary: Did you know you can put (almost) arbitrary data into a WAV file's PCM stream?
  It's true, and the results sound as mechanical...
tags: [ffmpeg, glitch, morningtoncrescent, audio]
timestamp: 1376721900
trail:
- blog:
    active: true
    name: abandonmentprobability
    theme: {avatar_shape: square, background_color: '#000000', body_font: Helvetica
        Neue, header_bounds: 0, header_image: 'https://secure.assets.tumblr.com/images/default_header/optica_pattern_08.png?_v=f0f055039bb6136b9661cf2227b535c2',
      header_image_focused: 'https://secure.assets.tumblr.com/images/default_header/optica_pattern_08.png?_v=f0f055039bb6136b9661cf2227b535c2',
      header_image_scaled: 'https://secure.assets.tumblr.com/images/default_header/optica_pattern_08.png?_v=f0f055039bb6136b9661cf2227b535c2',
      header_stretch: true, link_color: '#808080', show_avatar: true, show_description: true,
      show_header_image: false, show_title: true, title_color: '#FFFFFF', title_font: Helvetica
        Neue, title_font_weight: bold}
  content: "<p>Did you know you can put (almost) arbitrary data into a WAV file\u2019\
    s PCM stream? It\u2019s true, and the results sound as mechanical and unlistenable\
    \ as you might expect. In the spirit of the old Everything2 node <a href=\"http://everything2.com/title/catting+weird+things+to+%252Fdev%252Faudio\"\
    >\u201Ccatting weird things to /dev/audio\u201D</a>, here\u2019s how I created\
    \ this:</p>\n\n<pre><code>$ curl -s <a href=\"https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh\"\
    >https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh</a> |\
    \ \\\n  ffmpeg -codec:a pcm_s16le -f s16le -ac 2 -i - -f wav output.wav\n</code></pre>\n\
    \n<p>A breakdown of the above FFmpeg invocation:</p>\n\n<ul><li><p><code>-codec:a</code>\
    \ specifies the audio codec I want to use to decode the input data. Here, we\u2019\
    re pretending the C++ header file I fetch using <code>curl</code> is actually\
    \ signed 16-bit little-endian PCM audio data. You may also know this option as\
    \ <code>-acodec</code>.</p></li>\n<li><p><code>-f s16le</code> specifies the input\
    \ file format, which in this case is basically the same as the audio codec. This\
    \ is necessary to make FFmpeg understand that we\u2019re providing it with raw\
    \ data, and not expect file headers or metadata or what have you.</p></li>\n<li><p><code>-ac\
    \ 2</code> tells FFmpeg to treat the input as having two audio channels, in essence\
    \ stereo audio. You can leave this off and get mono audio; with the same data,\
    \ it sounds like it\u2019s being played at half-speed.</p></li>\n<li><p><code>-i\
    \ -</code> means that the data is coming from standard input.</p></li>\n<li><p><code>-f\
    \ wav</code> specifies the output file format. You might be thinking, \u201CWait,\
    \ didn\u2019t you already use <code>-f</code>?\u201D Indeed I did. Options that\
    \ come before <code>-i</code> generally apply to the input stream, while options\
    \ after it apply to the output stream. Intuitive, huh?</p></li>\n</ul><p>As is\
    \ my usual admonition, don\u2019t do this.</p>"
  content_raw: "<p>Did you know you can put (almost) arbitrary data into a WAV file\u2019\
    s PCM stream? It\u2019s true, and the results sound as mechanical and unlistenable\
    \ as you might expect. In the spirit of the old Everything2 node <a href=\"http://everything2.com/title/catting+weird+things+to+%252Fdev%252Faudio\"\
    >\u201Ccatting weird things to /dev/audio\u201D</a>, here\u2019s how I created\
    \ this:</p>\n\n<pre><code>$ curl -s <a href=\"https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh\"\
    >https://raw.github.com/knu/ruby-unf_ext/master/ext/unf_ext/unf/table.hh</a> |\
    \ \\\n  ffmpeg -codec:a pcm_s16le -f s16le -ac 2 -i - -f wav output.wav\n</code></pre>\n\
    \n<p>A breakdown of the above FFmpeg invocation:</p>\n\n<ul><li><p><code>-codec:a</code>\
    \ specifies the audio codec I want to use to decode the input data. Here, we\u2019\
    re pretending the C++ header file I fetch using <code>curl</code> is actually\
    \ signed 16-bit little-endian PCM audio data. You may also know this option as\
    \ <code>-acodec</code>.</p></li>\n<li><p><code>-f s16le</code> specifies the input\
    \ file format, which in this case is basically the same as the audio codec. This\
    \ is necessary to make FFmpeg understand that we\u2019re providing it with raw\
    \ data, and not expect file headers or metadata or what have you.</p></li>\n<li><p><code>-ac\
    \ 2</code> tells FFmpeg to treat the input as having two audio channels, in essence\
    \ stereo audio. You can leave this off and get mono audio; with the same data,\
    \ it sounds like it\u2019s being played at half-speed.</p></li>\n<li><p><code>-i\
    \ -</code> means that the data is coming from standard input.</p></li>\n<li><p><code>-f\
    \ wav</code> specifies the output file format. You might be thinking, \u201CWait,\
    \ didn\u2019t you already use <code>-f</code>?\u201D Indeed I did. Options that\
    \ come before <code>-i</code> generally apply to the input stream, while options\
    \ after it apply to the output stream. Intuitive, huh?</p></li>\n</ul><p>As is\
    \ my usual admonition, don\u2019t do this.</p>"
  is_current_item: true
  is_root_item: true
  post: {id: '58490554576'}
type: audio
